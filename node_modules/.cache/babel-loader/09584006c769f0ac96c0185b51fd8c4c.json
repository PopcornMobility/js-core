{"ast":null,"code":"import { SameValue, TimeClip } from '../../262';\nimport { ToLocalTime } from './ToLocalTime';\nimport { FormatDateTimePattern } from './FormatDateTimePattern';\nimport { PartitionPattern } from '../PartitionPattern';\nvar TABLE_2_FIELDS = ['era', 'year', 'month', 'day', 'ampm', 'hour', 'minute', 'second'];\nexport function PartitionDateTimeRangePattern(dtf, x, y, implDetails) {\n  x = TimeClip(x);\n\n  if (isNaN(x)) {\n    throw new RangeError('Invalid start time');\n  }\n\n  y = TimeClip(y);\n\n  if (isNaN(y)) {\n    throw new RangeError('Invalid end time');\n  }\n  /** IMPL START */\n\n\n  var getInternalSlots = implDetails.getInternalSlots,\n      tzData = implDetails.tzData;\n  var internalSlots = getInternalSlots(dtf);\n  /** IMPL END */\n\n  var tm1 = ToLocalTime(x, // @ts-ignore\n  internalSlots.calendar, internalSlots.timeZone, {\n    tzData: tzData\n  });\n  var tm2 = ToLocalTime(y, // @ts-ignore\n  internalSlots.calendar, internalSlots.timeZone, {\n    tzData: tzData\n  });\n  var pattern = internalSlots.pattern,\n      rangePatterns = internalSlots.rangePatterns;\n  var rangePattern;\n  var dateFieldsPracticallyEqual = true;\n  var patternContainsLargerDateField = false;\n\n  for (var _i = 0, TABLE_2_FIELDS_1 = TABLE_2_FIELDS; _i < TABLE_2_FIELDS_1.length; _i++) {\n    var fieldName = TABLE_2_FIELDS_1[_i];\n\n    if (dateFieldsPracticallyEqual && !patternContainsLargerDateField) {\n      if (fieldName === 'ampm') {\n        var v1 = tm1.hour;\n        var v2 = tm2.hour;\n        var rp = rangePatterns.ampm;\n\n        if (v1 > 11 && v2 < 11 || v1 < 11 && v2 > 11) {\n          dateFieldsPracticallyEqual = false;\n        }\n\n        if (rangePattern !== undefined && rp === undefined) {\n          patternContainsLargerDateField = true;\n        }\n\n        rangePattern = rp;\n      } else {\n        var v1 = tm1[fieldName];\n        var v2 = tm2[fieldName];\n        var rp = rangePatterns[fieldName];\n\n        if (!SameValue(v1, v2)) {\n          dateFieldsPracticallyEqual = false;\n        }\n\n        if (rangePattern !== undefined && rp === undefined) {\n          patternContainsLargerDateField = true;\n        }\n\n        rangePattern = rp;\n      }\n    }\n  }\n\n  if (dateFieldsPracticallyEqual) {\n    var result_2 = FormatDateTimePattern(dtf, PartitionPattern(pattern), x, implDetails);\n\n    for (var _a = 0, result_1 = result_2; _a < result_1.length; _a++) {\n      var r = result_1[_a];\n      r.source = \"shared\"\n      /* shared */\n      ;\n    }\n\n    return result_2;\n  }\n\n  var result = [];\n\n  if (rangePattern === undefined) {\n    rangePattern = rangePatterns.default;\n  }\n\n  for (var _b = 0, _c = rangePattern.patternParts; _b < _c.length; _b++) {\n    var rangePatternPart = _c[_b];\n    var source = rangePatternPart.source,\n        pattern_1 = rangePatternPart.pattern;\n    var z = void 0;\n\n    if (source === \"startRange\"\n    /* startRange */\n    || source === \"shared\"\n    /* shared */\n    ) {\n        z = x;\n      } else {\n      z = y;\n    }\n\n    var patternParts = PartitionPattern(pattern_1);\n    var partResult = FormatDateTimePattern(dtf, patternParts, z, implDetails);\n\n    for (var _d = 0, partResult_1 = partResult; _d < partResult_1.length; _d++) {\n      var r = partResult_1[_d];\n      r.source = source;\n    }\n\n    result = result.concat(partResult);\n  }\n\n  return result;\n}","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _classCallCheck from \"/Users/stefanm/Projects/js-core/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/stefanm/Projects/js-core/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar round = Math.round;\n/**\n * Support format, alpha unit will check the % mark:\n * - rgba(102, 204, 255, .5)      -> [102, 204, 255, 0.5]\n * - rgb(102 204 255 / .5)        -> [102, 204, 255, 0.5]\n * - rgb(100%, 50%, 0% / 50%)     -> [255, 128, 0, 0.5]\n * - hsl(270, 60, 40, .5)         -> [270, 60, 40, 0.5]\n * - hsl(270deg 60% 40% / 50%)   -> [270, 60, 40, 0.5]\n *\n * When `base` is provided, the percentage value will be divided by `base`.\n */\n\nfunction splitColorStr(str, parseNum) {\n  var match = str // Remove str before `(`\n  .replace(/^[^(]*\\((.*)/, '$1') // Remove str after `)`\n  .replace(/\\).*/, '').match(/\\d*\\.?\\d+%?/g) || [];\n  var numList = match.map(function (item) {\n    return parseFloat(item);\n  });\n\n  for (var i = 0; i < 3; i += 1) {\n    numList[i] = parseNum(numList[i] || 0, match[i] || '', i);\n  } // For alpha. 50% should be 0.5\n\n\n  if (match[3]) {\n    numList[3] = match[3].includes('%') ? numList[3] / 100 : numList[3];\n  } else {\n    // By default, alpha is 1\n    numList[3] = 1;\n  }\n\n  return numList;\n}\n\nvar parseHSVorHSL = function parseHSVorHSL(num, _, index) {\n  return index === 0 ? num : num / 100;\n};\n/** round and limit number to integer between 0-255 */\n\n\nfunction limitRange(value, max) {\n  var mergedMax = max || 255;\n\n  if (value > mergedMax) {\n    return mergedMax;\n  }\n\n  if (value < 0) {\n    return 0;\n  }\n\n  return value;\n}\n\nexport var FastColor = /*#__PURE__*/function () {\n  function FastColor(input) {\n    _classCallCheck(this, FastColor);\n\n    /**\n     * All FastColor objects are valid. So isValid is always true. This property is kept to be compatible with TinyColor.\n     */\n    _defineProperty(this, \"isValid\", true);\n    /**\n     * Red, R in RGB\n     */\n\n\n    _defineProperty(this, \"r\", 0);\n    /**\n     * Green, G in RGB\n     */\n\n\n    _defineProperty(this, \"g\", 0);\n    /**\n     * Blue, B in RGB\n     */\n\n\n    _defineProperty(this, \"b\", 0);\n    /**\n     * Alpha/Opacity, A in RGBA/HSLA\n     */\n\n\n    _defineProperty(this, \"a\", 1); // HSV privates\n\n\n    _defineProperty(this, \"_h\", void 0);\n\n    _defineProperty(this, \"_s\", void 0);\n\n    _defineProperty(this, \"_l\", void 0);\n\n    _defineProperty(this, \"_v\", void 0); // intermediate variables to calculate HSL/HSV\n\n\n    _defineProperty(this, \"_max\", void 0);\n\n    _defineProperty(this, \"_min\", void 0);\n\n    _defineProperty(this, \"_brightness\", void 0);\n    /**\n     * Always check 3 char in the object to determine the format.\n     * We not use function in check to save bundle size.\n     * e.g. 'rgb' -> { r: 0, g: 0, b: 0 }.\n     */\n\n\n    function matchFormat(str) {\n      return str[0] in input && str[1] in input && str[2] in input;\n    }\n\n    if (!input) {// Do nothing since already initialized\n    } else if (typeof input === 'string') {\n      var matchPrefix = function matchPrefix(prefix) {\n        return trimStr.startsWith(prefix);\n      };\n\n      var trimStr = input.trim();\n\n      if (/^#?[A-F\\d]{3,8}$/i.test(trimStr)) {\n        this.fromHexString(trimStr);\n      } else if (matchPrefix('rgb')) {\n        this.fromRgbString(trimStr);\n      } else if (matchPrefix('hsl')) {\n        this.fromHslString(trimStr);\n      } else if (matchPrefix('hsv') || matchPrefix('hsb')) {\n        this.fromHsvString(trimStr);\n      }\n    } else if (input instanceof FastColor) {\n      this.r = input.r;\n      this.g = input.g;\n      this.b = input.b;\n      this.a = input.a;\n      this._h = input._h;\n      this._s = input._s;\n      this._l = input._l;\n      this._v = input._v;\n    } else if (matchFormat('rgb')) {\n      this.r = limitRange(input.r);\n      this.g = limitRange(input.g);\n      this.b = limitRange(input.b);\n      this.a = typeof input.a === 'number' ? limitRange(input.a, 1) : 1;\n    } else if (matchFormat('hsl')) {\n      this.fromHsl(input);\n    } else if (matchFormat('hsv')) {\n      this.fromHsv(input);\n    } else {\n      throw new Error('@ant-design/fast-color: unsupported input ' + JSON.stringify(input));\n    }\n  } // ======================= Setter =======================\n\n\n  _createClass(FastColor, [{\n    key: \"setR\",\n    value: function setR(value) {\n      return this._sc('r', value);\n    }\n  }, {\n    key: \"setG\",\n    value: function setG(value) {\n      return this._sc('g', value);\n    }\n  }, {\n    key: \"setB\",\n    value: function setB(value) {\n      return this._sc('b', value);\n    }\n  }, {\n    key: \"setA\",\n    value: function setA(value) {\n      return this._sc('a', value, 1);\n    }\n  }, {\n    key: \"setHue\",\n    value: function setHue(value) {\n      var hsv = this.toHsv();\n      hsv.h = value;\n      return this._c(hsv);\n    } // ======================= Getter =======================\n\n    /**\n     * Returns the perceived luminance of a color, from 0-1.\n     * @see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n     */\n\n  }, {\n    key: \"getLuminance\",\n    value: function getLuminance() {\n      function adjustGamma(raw) {\n        var val = raw / 255;\n        return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);\n      }\n\n      var R = adjustGamma(this.r);\n      var G = adjustGamma(this.g);\n      var B = adjustGamma(this.b);\n      return 0.2126 * R + 0.7152 * G + 0.0722 * B;\n    }\n  }, {\n    key: \"getHue\",\n    value: function getHue() {\n      if (typeof this._h === 'undefined') {\n        var delta = this.getMax() - this.getMin();\n\n        if (delta === 0) {\n          this._h = 0;\n        } else {\n          this._h = round(60 * (this.r === this.getMax() ? (this.g - this.b) / delta + (this.g < this.b ? 6 : 0) : this.g === this.getMax() ? (this.b - this.r) / delta + 2 : (this.r - this.g) / delta + 4));\n        }\n      }\n\n      return this._h;\n    }\n  }, {\n    key: \"getSaturation\",\n    value: function getSaturation() {\n      if (typeof this._s === 'undefined') {\n        var delta = this.getMax() - this.getMin();\n\n        if (delta === 0) {\n          this._s = 0;\n        } else {\n          this._s = delta / this.getMax();\n        }\n      }\n\n      return this._s;\n    }\n  }, {\n    key: \"getLightness\",\n    value: function getLightness() {\n      if (typeof this._l === 'undefined') {\n        this._l = (this.getMax() + this.getMin()) / 510;\n      }\n\n      return this._l;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      if (typeof this._v === 'undefined') {\n        this._v = this.getMax() / 255;\n      }\n\n      return this._v;\n    }\n    /**\n     * Returns the perceived brightness of the color, from 0-255.\n     * Note: this is not the b of HSB\n     * @see http://www.w3.org/TR/AERT#color-contrast\n     */\n\n  }, {\n    key: \"getBrightness\",\n    value: function getBrightness() {\n      if (typeof this._brightness === 'undefined') {\n        this._brightness = (this.r * 299 + this.g * 587 + this.b * 114) / 1000;\n      }\n\n      return this._brightness;\n    } // ======================== Func ========================\n\n  }, {\n    key: \"darken\",\n    value: function darken() {\n      var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n      var h = this.getHue();\n      var s = this.getSaturation();\n      var l = this.getLightness() - amount / 100;\n\n      if (l < 0) {\n        l = 0;\n      }\n\n      return this._c({\n        h: h,\n        s: s,\n        l: l,\n        a: this.a\n      });\n    }\n  }, {\n    key: \"lighten\",\n    value: function lighten() {\n      var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n      var h = this.getHue();\n      var s = this.getSaturation();\n      var l = this.getLightness() + amount / 100;\n\n      if (l > 1) {\n        l = 1;\n      }\n\n      return this._c({\n        h: h,\n        s: s,\n        l: l,\n        a: this.a\n      });\n    }\n    /**\n     * Mix the current color a given amount with another color, from 0 to 100.\n     * 0 means no mixing (return current color).\n     */\n\n  }, {\n    key: \"mix\",\n    value: function mix(input) {\n      var _this = this;\n\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;\n\n      var color = this._c(input);\n\n      var p = amount / 100;\n\n      var calc = function calc(key) {\n        return (color[key] - _this[key]) * p + _this[key];\n      };\n\n      var rgba = {\n        r: round(calc('r')),\n        g: round(calc('g')),\n        b: round(calc('b')),\n        a: round(calc('a') * 100) / 100\n      };\n      return this._c(rgba);\n    }\n    /**\n     * Mix the color with pure white, from 0 to 100.\n     * Providing 0 will do nothing, providing 100 will always return white.\n     */\n\n  }, {\n    key: \"tint\",\n    value: function tint() {\n      var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n      return this.mix({\n        r: 255,\n        g: 255,\n        b: 255,\n        a: 1\n      }, amount);\n    }\n    /**\n     * Mix the color with pure black, from 0 to 100.\n     * Providing 0 will do nothing, providing 100 will always return black.\n     */\n\n  }, {\n    key: \"shade\",\n    value: function shade() {\n      var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n      return this.mix({\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 1\n      }, amount);\n    }\n  }, {\n    key: \"onBackground\",\n    value: function onBackground(background) {\n      var _this2 = this;\n\n      var bg = this._c(background);\n\n      var alpha = this.a + bg.a * (1 - this.a);\n\n      var calc = function calc(key) {\n        return round((_this2[key] * _this2.a + bg[key] * bg.a * (1 - _this2.a)) / alpha);\n      };\n\n      return this._c({\n        r: calc('r'),\n        g: calc('g'),\n        b: calc('b'),\n        a: alpha\n      });\n    } // ======================= Status =======================\n\n  }, {\n    key: \"isDark\",\n    value: function isDark() {\n      return this.getBrightness() < 128;\n    }\n  }, {\n    key: \"isLight\",\n    value: function isLight() {\n      return this.getBrightness() >= 128;\n    } // ======================== MISC ========================\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return this._c(this);\n    } // ======================= Format =======================\n\n  }, {\n    key: \"toHexString\",\n    value: function toHexString() {\n      var hex = '#';\n      var rHex = (this.r || 0).toString(16);\n      hex += rHex.length === 2 ? rHex : '0' + rHex;\n      var gHex = (this.g || 0).toString(16);\n      hex += gHex.length === 2 ? gHex : '0' + gHex;\n      var bHex = (this.b || 0).toString(16);\n      hex += bHex.length === 2 ? bHex : '0' + bHex;\n\n      if (typeof this.a === 'number' && this.a >= 0 && this.a < 1) {\n        var aHex = round(this.a * 255).toString(16);\n        hex += aHex.length === 2 ? aHex : '0' + aHex;\n      }\n\n      return hex;\n    }\n    /** CSS support color pattern */\n\n  }, {\n    key: \"toHsl\",\n    value: function toHsl() {\n      return {\n        h: this.getHue(),\n        s: this.getSaturation(),\n        l: this.getLightness(),\n        a: this.a\n      };\n    }\n    /** CSS support color pattern */\n\n  }, {\n    key: \"toHslString\",\n    value: function toHslString() {\n      var h = this.getHue();\n      var s = round(this.getSaturation() * 100);\n      var l = round(this.getLightness() * 100);\n      return this.a !== 1 ? \"hsla(\".concat(h, \",\").concat(s, \"%,\").concat(l, \"%,\").concat(this.a, \")\") : \"hsl(\".concat(h, \",\").concat(s, \"%,\").concat(l, \"%)\");\n    }\n    /** Same as toHsb */\n\n  }, {\n    key: \"toHsv\",\n    value: function toHsv() {\n      return {\n        h: this.getHue(),\n        s: this.getSaturation(),\n        v: this.getValue(),\n        a: this.a\n      };\n    }\n  }, {\n    key: \"toRgb\",\n    value: function toRgb() {\n      return {\n        r: this.r,\n        g: this.g,\n        b: this.b,\n        a: this.a\n      };\n    }\n  }, {\n    key: \"toRgbString\",\n    value: function toRgbString() {\n      return this.a !== 1 ? \"rgba(\".concat(this.r, \",\").concat(this.g, \",\").concat(this.b, \",\").concat(this.a, \")\") : \"rgb(\".concat(this.r, \",\").concat(this.g, \",\").concat(this.b, \")\");\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.toRgbString();\n    } // ====================== Privates ======================\n\n    /** Return a new FastColor object with one channel changed */\n\n  }, {\n    key: \"_sc\",\n    value: function _sc(rgb, value, max) {\n      var clone = this.clone();\n      clone[rgb] = limitRange(value, max);\n      return clone;\n    }\n  }, {\n    key: \"_c\",\n    value: function _c(input) {\n      return new this.constructor(input);\n    }\n  }, {\n    key: \"getMax\",\n    value: function getMax() {\n      if (typeof this._max === 'undefined') {\n        this._max = Math.max(this.r, this.g, this.b);\n      }\n\n      return this._max;\n    }\n  }, {\n    key: \"getMin\",\n    value: function getMin() {\n      if (typeof this._min === 'undefined') {\n        this._min = Math.min(this.r, this.g, this.b);\n      }\n\n      return this._min;\n    }\n  }, {\n    key: \"fromHexString\",\n    value: function fromHexString(trimStr) {\n      var withoutPrefix = trimStr.replace('#', '');\n\n      function connectNum(index1, index2) {\n        return parseInt(withoutPrefix[index1] + withoutPrefix[index2 || index1], 16);\n      }\n\n      if (withoutPrefix.length < 6) {\n        // #rgb or #rgba\n        this.r = connectNum(0);\n        this.g = connectNum(1);\n        this.b = connectNum(2);\n        this.a = withoutPrefix[3] ? connectNum(3) / 255 : 1;\n      } else {\n        // #rrggbb or #rrggbbaa\n        this.r = connectNum(0, 1);\n        this.g = connectNum(2, 3);\n        this.b = connectNum(4, 5);\n        this.a = withoutPrefix[6] ? connectNum(6, 7) / 255 : 1;\n      }\n    }\n  }, {\n    key: \"fromHsl\",\n    value: function fromHsl(_ref) {\n      var h = _ref.h,\n          s = _ref.s,\n          l = _ref.l,\n          a = _ref.a;\n      this._h = h % 360;\n      this._s = s;\n      this._l = l;\n      this.a = typeof a === 'number' ? a : 1;\n\n      if (s <= 0) {\n        var rgb = round(l * 255);\n        this.r = rgb;\n        this.g = rgb;\n        this.b = rgb;\n      }\n\n      var r = 0,\n          g = 0,\n          b = 0;\n      var huePrime = h / 60;\n      var chroma = (1 - Math.abs(2 * l - 1)) * s;\n      var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));\n\n      if (huePrime >= 0 && huePrime < 1) {\n        r = chroma;\n        g = secondComponent;\n      } else if (huePrime >= 1 && huePrime < 2) {\n        r = secondComponent;\n        g = chroma;\n      } else if (huePrime >= 2 && huePrime < 3) {\n        g = chroma;\n        b = secondComponent;\n      } else if (huePrime >= 3 && huePrime < 4) {\n        g = secondComponent;\n        b = chroma;\n      } else if (huePrime >= 4 && huePrime < 5) {\n        r = secondComponent;\n        b = chroma;\n      } else if (huePrime >= 5 && huePrime < 6) {\n        r = chroma;\n        b = secondComponent;\n      }\n\n      var lightnessModification = l - chroma / 2;\n      this.r = round((r + lightnessModification) * 255);\n      this.g = round((g + lightnessModification) * 255);\n      this.b = round((b + lightnessModification) * 255);\n    }\n  }, {\n    key: \"fromHsv\",\n    value: function fromHsv(_ref2) {\n      var h = _ref2.h,\n          s = _ref2.s,\n          v = _ref2.v,\n          a = _ref2.a;\n      this._h = h % 360;\n      this._s = s;\n      this._v = v;\n      this.a = typeof a === 'number' ? a : 1;\n      var vv = round(v * 255);\n      this.r = vv;\n      this.g = vv;\n      this.b = vv;\n\n      if (s <= 0) {\n        return;\n      }\n\n      var hh = h / 60;\n      var i = Math.floor(hh);\n      var ff = hh - i;\n      var p = round(v * (1.0 - s) * 255);\n      var q = round(v * (1.0 - s * ff) * 255);\n      var t = round(v * (1.0 - s * (1.0 - ff)) * 255);\n\n      switch (i) {\n        case 0:\n          this.g = t;\n          this.b = p;\n          break;\n\n        case 1:\n          this.r = q;\n          this.b = p;\n          break;\n\n        case 2:\n          this.r = p;\n          this.b = t;\n          break;\n\n        case 3:\n          this.r = p;\n          this.g = q;\n          break;\n\n        case 4:\n          this.r = t;\n          this.g = p;\n          break;\n\n        case 5:\n        default:\n          this.g = p;\n          this.b = q;\n          break;\n      }\n    }\n  }, {\n    key: \"fromHsvString\",\n    value: function fromHsvString(trimStr) {\n      var cells = splitColorStr(trimStr, parseHSVorHSL);\n      this.fromHsv({\n        h: cells[0],\n        s: cells[1],\n        v: cells[2],\n        a: cells[3]\n      });\n    }\n  }, {\n    key: \"fromHslString\",\n    value: function fromHslString(trimStr) {\n      var cells = splitColorStr(trimStr, parseHSVorHSL);\n      this.fromHsl({\n        h: cells[0],\n        s: cells[1],\n        l: cells[2],\n        a: cells[3]\n      });\n    }\n  }, {\n    key: \"fromRgbString\",\n    value: function fromRgbString(trimStr) {\n      var cells = splitColorStr(trimStr, function (num, txt) {\n        return (// Convert percentage to number. e.g. 50% -> 128\n          txt.includes('%') ? round(num / 100 * 255) : num\n        );\n      });\n      this.r = cells[0];\n      this.g = cells[1];\n      this.b = cells[2];\n      this.a = cells[3];\n    }\n  }]);\n\n  return FastColor;\n}();","map":null,"metadata":{},"sourceType":"module"}